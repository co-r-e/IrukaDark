<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IrukaDark Logo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        background: transparent;
        overflow: hidden;
      }

      .logo-container {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        cursor: move;
        -webkit-app-region: no-drag; /* manual drag via JS to allow click detection */
        /* Ensure transparent window receives events across the whole rect */
        background: rgba(0, 0, 0, 0.001);
        pointer-events: auto;
      }

      .logo {
        width: 84px;
        height: 84px;
        /* No hover/active scaling */
      }
      .fallback-logo {
        width: 84px;
        height: 84px;
        background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
        border-radius: 20px;
        display: none;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
      }
      .fallback-logo svg {
        width: 42px;
        height: 42px;
        color: white;
      }
    </style>
  </head>
  <body>
    <div class="logo-container" id="logoContainer">
      <img
        id="logoImg"
        src="assets/icons/irukadark_logo.svg"
        alt="IrukaDark Logo"
        class="logo"
        onerror="this.style.display='none'; document.getElementById('fallbackLogo').style.display='flex';"
      />
      <div id="fallbackLogo" class="fallback-logo">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="60"
          height="60"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <path d="M12 8V4H8" />
          <rect width="16" height="12" x="4" y="8" rx="2" />
          <path d="M2 14h2" />
          <path d="M20 14h2" />
          <path d="M15 13v2" />
          <path d="M9 13v2" />
        </svg>
      </div>
    </div>

    <script>
      /**
       * DragController - Manages popup window dragging with responsive IPC communication
       * Uses fire-and-forget IPC calls for immediate response during drag
       */
      class DragController {
        // Constants
        static DRAG_THRESHOLD = 0; // Minimum distance to consider as drag
        static DEBUG_MODE = false; // Set to true for console logging

        /**
         * @param {Object} api - Electron API interface
         * @param {HTMLElement} targetElement - Element to attach drag handlers to
         */
        constructor(api, targetElement) {
          this.api = api;
          this.targetElement = targetElement;

          // Drag state
          this.isDragging = false;
          this.hasMoved = false;
          this.startScreenX = 0;
          this.startScreenY = 0;
          this.startBounds = null;
          this.currentPointerId = null;

          // Event support detection
          this.supportsPointer = 'onpointerdown' in window;
          this.downEvent = this.supportsPointer ? 'pointerdown' : 'mousedown';
          this.moveEvent = this.supportsPointer ? 'pointermove' : 'mousemove';
          this.upEvent = this.supportsPointer ? 'pointerup' : 'mouseup';

          // AbortController for cleanup
          this.abortController = new AbortController();

          this.log('DragController initialized');
          this.attachEventListeners();
        }

        /**
         * Debug logging helper
         */
        log(...args) {
          if (DragController.DEBUG_MODE) {
            console.log('[DragController]', ...args);
          }
        }

        /**
         * Attach all event listeners with AbortController for proper cleanup
         */
        attachEventListeners() {
          const options = { capture: true, signal: this.abortController.signal };

          this.targetElement.addEventListener(this.downEvent, this.handleDown.bind(this), options);
          this.targetElement.addEventListener(this.moveEvent, this.handleMove.bind(this), options);
          this.targetElement.addEventListener(this.upEvent, this.handleUp.bind(this), options);

          if (this.supportsPointer) {
            this.targetElement.addEventListener(
              'lostpointercapture',
              this.handleLostCapture.bind(this),
              options
            );
          }

          // Cleanup on window unload
          window.addEventListener(
            'beforeunload',
            () => {
              this.cleanup();
            },
            options
          );
        }

        /**
         * Notify main process of pointer phase
         */
        notifyPhase(phase) {
          try {
            if (this.api.notifyPopupPointer) {
              this.api.notifyPopupPointer(phase);
            }
          } catch (error) {
            this.log('Error notifying phase:', error);
          }
        }

        /**
         * Get current popup window bounds
         */
        async getBounds() {
          try {
            if (!this.api.getPopupBounds) {
              throw new Error('getPopupBounds API not available');
            }
            return await this.api.getPopupBounds();
          } catch (error) {
            this.log('Error getting bounds:', error);
            return null;
          }
        }

        /**
         * Set popup window position (fire-and-forget for immediate response)
         */
        async setPosition(x, y) {
          try {
            if (!this.api.setPopupPosition) {
              throw new Error('setPopupPosition API not available');
            }
            // Direct IPC call without throttling for immediate response
            // Don't await - fire and forget for maximum responsiveness
            this.api.setPopupPosition(Math.round(x), Math.round(y));
            this.log('Position updated:', x, y);
          } catch (error) {
            this.log('Error setting position:', error);
            // Keep drag state intact even if IPC fails
          }
        }

        /**
         * Handle pointer/mouse down event
         */
        async handleDown(event) {
          try {
            event.preventDefault();
          } catch {}

          this.log('Pointer down');

          // Get initial bounds
          this.startBounds = await this.getBounds();
          if (!this.startBounds) {
            this.log('Failed to get initial bounds');
            return;
          }

          // Initialize drag state
          this.isDragging = true;
          this.hasMoved = false;
          this.startScreenX = event.screenX;
          this.startScreenY = event.screenY;
          this.currentPointerId = event.pointerId ?? null;

          // Set pointer capture for reliable drag tracking
          if (
            this.supportsPointer &&
            this.currentPointerId != null &&
            event.target?.setPointerCapture
          ) {
            try {
              event.target.setPointerCapture(this.currentPointerId);
              this.log('Pointer capture set:', this.currentPointerId);
            } catch (error) {
              this.log('Failed to set pointer capture:', error);
            }
          }

          this.notifyPhase('down');
        }

        /**
         * Handle pointer/mouse move event
         */
        handleMove(event) {
          if (!this.isDragging || !this.startBounds) {
            return;
          }

          const dx = event.screenX - this.startScreenX;
          const dy = event.screenY - this.startScreenY;

          // Track if moved beyond threshold
          if (Math.abs(dx) + Math.abs(dy) > DragController.DRAG_THRESHOLD) {
            this.hasMoved = true;
          }

          // Update position immediately for responsive tracking
          this.setPosition(this.startBounds.x + dx, this.startBounds.y + dy);
        }

        /**
         * Handle pointer/mouse up event
         */
        handleUp(event) {
          if (!this.isDragging) {
            return;
          }

          this.log('Pointer up, moved:', this.hasMoved);

          this.isDragging = false;

          // Release pointer capture
          if (
            this.supportsPointer &&
            this.currentPointerId != null &&
            event.target?.releasePointerCapture
          ) {
            try {
              event.target.releasePointerCapture(this.currentPointerId);
              this.log('Pointer capture released');
            } catch (error) {
              this.log('Failed to release pointer capture:', error);
            }
          }

          this.currentPointerId = null;
          this.notifyPhase('up');
        }

        /**
         * Handle lost pointer capture event
         */
        handleLostCapture(event) {
          this.log('Lost pointer capture');

          if (this.isDragging) {
            // Attempt to recapture
            if (event.pointerId != null && event.target?.setPointerCapture) {
              try {
                event.target.setPointerCapture(event.pointerId);
                this.log('Pointer recaptured');
              } catch (error) {
                this.log('Failed to recapture pointer, ending drag');
                this.isDragging = false;
                this.notifyPhase('up');
              }
            }
          }
        }

        /**
         * Clean up resources and event listeners
         */
        cleanup() {
          this.log('Cleaning up DragController');

          // Abort all event listeners
          this.abortController.abort();

          // Clear state
          this.isDragging = false;
          this.startBounds = null;
        }

        /**
         * Destroy the controller
         */
        destroy() {
          this.cleanup();
        }
      }

      // Initialize drag controller when DOM is ready
      (function initPopupDrag() {
        try {
          const api = window.electronAPI;
          if (!api) {
            console.error('Electron API not available');
            return;
          }

          const container = document.getElementById('logoContainer');
          if (!container) {
            console.error('Logo container not found');
            return;
          }

          // Create and initialize drag controller
          const dragController = new DragController(api, container);

          // Store reference for potential cleanup
          window.dragController = dragController;
        } catch (error) {
          console.error('Failed to initialize popup drag:', error);
        }
      })();
    </script>
  </body>
</html>
